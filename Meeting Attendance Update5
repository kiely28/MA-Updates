Thanks for sharing your full code üëç
I reviewed both your .aspx markup and code-behind, and overall it looks structured and should work. I‚Äôll highlight some issues, fixes, and suggestions:


---

üîé Markup (ASPX) Issues & Fixes

1. View Attendees Button

<button class="btn btn-info text-white me-2 w-auto">View Attendees</button>

This is plain HTML, so it won‚Äôt trigger your btnViewAttendees_Click event in code-behind.
‚úÖ Replace with:


<asp:Button ID="btnViewAttendees" runat="server" CssClass="btn btn-info text-white me-2 w-auto"
    Text="View Attendees" OnClick="btnViewAttendees_Click" />


2. End Meeting Button

<button class="btn btn-danger w-auto">End Meeting</button>

Same problem: plain <button> won‚Äôt hit server-side events.
‚úÖ Replace with:


<asp:Button ID="btnEndMeeting" runat="server" CssClass="btn btn-danger w-auto"
    Text="End Meeting" OnClick="btnEndMeeting_Click" />




---

üîé Code-behind Issues & Fixes

1. Employee Info Mapping

empName = reader["FirstName"].ToString();
dept = reader["LastName"].ToString();
sec = reader["FirstName"].ToString();

Looks like a copy-paste bug: you assign FirstName twice.
‚úÖ Correct mapping should be (adjust to your table fields):


empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
dept = reader["Department"].ToString();
sec = reader["Section"].ToString();


2. Duplicate Attendee Handling

object result = insertCmd.ExecuteScalar();
if (result != null && result.ToString() == "0")

This works if your stored procedure returns "0" for duplicates.
‚úÖ Consider making it more explicit (e.g., return an output parameter) for readability:


RETURN 0 -- duplicate
RETURN 1 -- success


3. Auto Fade-Out Alert

You correctly used:

ScriptManager.RegisterStartupScript(this, GetType(), "fadeOutAlert", "fadeOutAlert();", true);


‚úÖ Ensure your <form runat="server"> is wrapped inside a ScriptManager:

<asp:ScriptManager ID="ScriptManager1" runat="server" />




---

üîé Recommended Improvements

SQL Injection Safety ‚Üí You already use stored procedures, ‚úÖ good.

Error Handling ‚Üí Wrap DB code in try-catch to show a friendly error in alert.

Separation of Concerns ‚Üí Consider moving DB logic into a helper class (cleaner code-behind).

UX ‚Üí Disable the txtCardSerial after tap for 1s to prevent double-post.



---

‚úÖ With these changes, your page will:

Correctly redirect when clicking "View Attendees".

Handle "End Meeting" server-side.

Show correct employee details.

Keep the Bootstrap alerts working smoothly.



---

Do you want me to add the End Meeting logic in your code-behind (e.g., update meeting status + redirect), or just keep the button wired up?


-- Update 12:20
Good question üëç If you want the cursor to always focus on the txtCardSerial textbox, there are a couple of clean ways to do it in ASP.NET Web Forms.


---

‚úÖ Option 1: Use Page.SetFocus in Page_Load

In your meetingattendance.aspx.cs:

protected void Page_Load(object sender, EventArgs e)
{
    if (!IsPostBack)
    {
        string meetingId = Request.QueryString["meetingId"];
        if (!string.IsNullOrEmpty(meetingId))
        {
            LoadMeetingDetails(meetingId);
        }
        else
        {
            lblTitle.Text = "Invalid Meeting";
            lblDateTime.Text = "";
        }
    }

    // Always focus on the textbox after page load or postback
    Page.SetFocus(txtCardSerial);
}


---

‚úÖ Option 2: Use JavaScript for Continuous Focus

Sometimes after postbacks or if the user clicks elsewhere, the focus is lost.
You can enforce focus via JS:

In your ASPX page (inside <form> but after textbox):

<script type="text/javascript">
    window.onload = function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    };

    // Re-focus after each partial postback (if using UpdatePanel in future)
    Sys.WebForms.PageRequestManager.getInstance().add_endRequest(function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    });
</script>


---

‚úÖ Option 3: Force Focus After Tapping

At the end of your txtCardSerial_TextChanged handler:

txtCardSerial.Text = "";
ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
    $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);

This way, after every tap, the textbox clears and gets focus again.


---

üëâ Best practice:
Use Option 1 (SetFocus) for initial load + Option 3 (set focus again after postback) so your input is always ready for the next card swipe.


---

Do you want me to integrate this directly into your txtCardSerial_TextChanged method and Page_Load so it‚Äôs copy-paste ready?



-- Update 12:39
Got it üëç You already have the Tap-In logic (which inserts into MA_InsertAttendee), so for Tap-Out, we‚Äôll just update the record‚Äôs TimeOut instead of inserting again.

Here‚Äôs how we can do it step by step:


---

1. Add Tap Mode Selection (Radio Button)

You already have In/Out radio buttons in your markup.
They just need to be tied to server code.

Change your radio buttons like this:

<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioIn" runat="server" GroupName="TapMode" Checked="true"
        CssClass="btn-check" />
    <label class="btn btn-outline-primary w-100 btn-lg" for="<%= radioIn.ClientID %>">In</label>
</div>
<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioOut" runat="server" GroupName="TapMode"
        CssClass="btn-check" />
    <label class="btn btn-outline-secondary w-100 btn-lg" for="<%= radioOut.ClientID %>">Out</label>
</div>


---

2. Update txtCardSerial_TextChanged

We‚Äôll detect if the user tapped In or Out, then run the correct stored procedure.

protected void txtCardSerial_TextChanged(object sender, EventArgs e)
{
    string cardSerial = txtCardSerial.Text.Trim();
    string meetingId = hfMeetingID.Value;

    if (string.IsNullOrEmpty(cardSerial))
    {
        ShowAlert("Invalid Tap", "Please place your card on the reader.", "", "alert-warning");
        return;
    }

    string connStr = ConfigurationManager.ConnectionStrings["MeetingDb"].ConnectionString;

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        conn.Open();

        // 1. Validate Employee
        string empName = "";
        string dept = "";
        string sec = "";

        using (SqlCommand cmd = new SqlCommand("MA_CheckEmployeeByCard", conn))
        {
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

            SqlDataReader reader = cmd.ExecuteReader();
            if (!reader.Read())
            {
                ShowAlert("Card Not Registered", "Unknown Card", "", "alert-danger");
                return;
            }

            empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
            dept = reader["Department"].ToString();
            sec = reader["Section"].ToString();
            reader.Close();
        }

        // 2. Check tap mode (In/Out)
        if (radioIn.Checked)
        {
            // Insert (Tap-In)
            using (SqlCommand insertCmd = new SqlCommand("MA_InsertAttendee", conn))
            {
                insertCmd.CommandType = CommandType.StoredProcedure;
                insertCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                insertCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                object result = insertCmd.ExecuteScalar();

                if (result != null && result.ToString() == "0")
                {
                    ShowAlert("Already Tapped In", empName, $"{dept} - {sec}", "alert-warning");
                }
                else
                {
                    ShowAlert("You have tapped in successfully!", empName, $"{dept} - {sec}", "alert-success");
                }
            }
        }
        else if (radioOut.Checked)
        {
            // Update (Tap-Out)
            using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
            {
                updateCmd.CommandType = CommandType.StoredProcedure;
                updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                int rows = updateCmd.ExecuteNonQuery();

                if (rows > 0)
                {
                    ShowAlert("You have tapped out successfully!", empName, $"{dept} - {sec}", "alert-info");
                }
                else
                {
                    ShowAlert("No active tap-in found", empName, $"{dept} - {sec}", "alert-warning");
                }
            }
        }

        // Clear for next tap
        txtCardSerial.Text = "";
        ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
            $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);
    }
}


---

3. New Stored Procedure for Tap-Out

Add this to your SQL database:

CREATE PROCEDURE MA_UpdateAttendeeTimeout
    @MeetingId NVARCHAR(50),
    @CardSerialNo NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE MeetingAttendees
    SET TimeOut = GETDATE()
    WHERE MeetingId = @MeetingId
      AND CardSerialNo = @CardSerialNo
      AND TimeOut IS NULL; -- only update if still active
END


---

‚úÖ Now your workflow is:

Tap-In ‚Üí Inserts new record (TimeIn).

Tap-Out ‚Üí Updates TimeOut of the existing record (no duplicate inserts).



---

Do you want me to also prevent multiple Tap-Outs (so they can‚Äôt tap out twice in the same meeting), or should it just silently update TimeOut every time?


-- 12:45
Got it üëç ‚Äî I see why your radio buttons aren‚Äôt behaving:

You used Bootstrap‚Äôs btn-check style with plain <input type="radio">, but then in code-behind you tried to check radioIn.Checked.

That works only if the radio is an ASP.NET RadioButton server control.

Right now, your markup has a mismatch: input is HTML, but your code expects <asp:RadioButton>.



---

‚úÖ Fix: Use ASP.NET RadioButton with Bootstrap Styling

Here‚Äôs how to wire it correctly:

<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioIn" runat="server" GroupName="TapMode" Checked="true"
        CssClass="btn-check" />
    <label class="btn btn-outline-primary w-100 btn-lg" for="radioIn">In</label>
</div>

<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioOut" runat="server" GroupName="TapMode"
        CssClass="btn-check" />
    <label class="btn btn-outline-secondary w-100 btn-lg" for="radioOut">Out</label>
</div>


---

üîé Why this works

<asp:RadioButton> renders to <input type="radio"> with an auto-generated ID.

The for="radioIn" on the <label> won‚Äôt match unless you explicitly set the client-side id.

ASP.NET allows this by adding ClientIDMode="Static".


So update it like this:

<asp:RadioButton ID="radioIn" runat="server" GroupName="TapMode" Checked="true"
    CssClass="btn-check" ClientIDMode="Static" />
<label class="btn btn-outline-primary w-100 btn-lg" for="radioIn">In</label>

<asp:RadioButton ID="radioOut" runat="server" GroupName="TapMode"
    CssClass="btn-check" ClientIDMode="Static" />
<label class="btn btn-outline-secondary w-100 btn-lg" for="radioOut">Out</label>

Now:

Bootstrap styling works (btn-check).

Labels toggle correctly.

In C#, you can reliably check:

if (radioIn.Checked) { ... } 
else if (radioOut.Checked) { ... }



---

‚ö° Question for you: Do you want the default mode always set to Tap-In every time the page reloads, or should it remember the last selection (even after postback)?


-- 01:09
Alright üëç let‚Äôs fully integrate the Bootstrap radio toggle + hidden field into your code.


---

‚úÖ Markup (meetingattendance.aspx)

Replace your current radio buttons section with this:

<div class="row">
    <div class="col-3 col-lg-3 mb-3">
        <input type="radio" class="btn-check" name="tapMode" id="radioIn" value="In" autocomplete="off" checked>
        <label class="btn btn-outline-primary w-100 btn-lg" for="radioIn">In</label>
    </div>
    <div class="col-3 col-lg-3 mb-3">
        <input type="radio" class="btn-check" name="tapMode" id="radioOut" value="Out" autocomplete="off">
        <label class="btn btn-outline-secondary w-100 btn-lg" for="radioOut">Out</label>
    </div>
    <div class="col-6 d-flex justify-content-end">
        <div>
            <asp:Button ID="btnViewAttendees" runat="server" CssClass="btn btn-info text-white me-2 w-auto"
                Text="View Attendees" OnClick="btnViewAttendees_Click" />
            <asp:Button ID="btnEndMeeting" runat="server" CssClass="btn btn-danger w-auto"
                Text="End Meeting" OnClick="btnEndMeeting_Click" />
        </div>
    </div>
</div>

<!-- Hidden field to hold selected mode -->
<asp:HiddenField ID="hfTapMode" runat="server" />

And below it (inside the same page, after the form), add:

<script type="text/javascript">
    document.querySelectorAll('input[name="tapMode"]').forEach(function (radio) {
        radio.addEventListener('change', function () {
            document.getElementById('<%= hfTapMode.ClientID %>').value = this.value;
        });
    });

    // Initialize default (In) on page load
    document.addEventListener("DOMContentLoaded", function () {
        document.getElementById('<%= hfTapMode.ClientID %>').value = "In";
    });
</script>


---

‚úÖ Code-behind (meetingattendance.aspx.cs)

Now update your txtCardSerial_TextChanged method like this:

protected void txtCardSerial_TextChanged(object sender, EventArgs e)
{
    string cardSerial = txtCardSerial.Text.Trim();
    string meetingId = hfMeetingID.Value;
    string tapMode = hfTapMode.Value; // "In" or "Out"

    if (string.IsNullOrEmpty(cardSerial))
    {
        ShowAlert("Invalid Tap", "Please place your card on the reader.", "", "alert-warning");
        return;
    }

    string connStr = ConfigurationManager.ConnectionStrings["MeetingDb"].ConnectionString;

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        conn.Open();

        // 1. Validate Employee
        string empName = "";
        string dept = "";
        string sec = "";

        using (SqlCommand cmd = new SqlCommand("MA_CheckEmployeeByCard", conn))
        {
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

            SqlDataReader reader = cmd.ExecuteReader();
            if (!reader.Read())
            {
                ShowAlert("Card Not Registered", "Unknown Card", "", "alert-danger");
                return;
            }

            empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
            dept = reader["Department"].ToString();
            sec = reader["Section"].ToString();
            reader.Close();
        }

        // 2. Tap-In or Tap-Out
        if (tapMode == "In")
        {
            using (SqlCommand insertCmd = new SqlCommand("MA_InsertAttendee", conn))
            {
                insertCmd.CommandType = CommandType.StoredProcedure;
                insertCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                insertCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                object result = insertCmd.ExecuteScalar();

                if (result != null && result.ToString() == "0")
                {
                    ShowAlert("Already Tapped In", empName, $"{dept} - {sec}", "alert-warning");
                }
                else
                {
                    ShowAlert("You have tapped in successfully!", empName, $"{dept} - {sec}", "alert-success");
                }
            }
        }
        else if (tapMode == "Out")
        {
            using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
            {
                updateCmd.CommandType = CommandType.StoredProcedure;
                updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                object result = updateCmd.ExecuteScalar();
                int rows = (result != null) ? Convert.ToInt32(result) : 0;

                if (rows > 0)
                {
                    ShowAlert("You have tapped out successfully!", empName, $"{dept} - {sec}", "alert-info");
                }
                else
                {
                    ShowAlert("Already tapped out or no tap-in found", empName, $"{dept} - {sec}", "alert-warning");
                }
            }
        }

        // 3. Reset for next tap
        txtCardSerial.Text = "";
        ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
            $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);
    }
}


---

‚úÖ Flow Now

1. User selects In or Out (Bootstrap toggle).


2. JavaScript updates the hidden field hfTapMode.


3. When ID is tapped ‚Üí server reads hfTapMode.Value.


4. Runs either Insert (Tap-In) or Update (Tap-Out, one time only).


5. Shows the correct Bootstrap alert.




---

Would you like me to also update your ShowAlert so that it uses different alert colors/icons automatically depending on tap mode (In/Out) instead of passing them manually?



-- Update 02:35
Perfect üëç let me give you the complete working version (ASPX + CodeBehind) with:

Bootstrap-styled toggle buttons (Tap In / Tap Out)

Hidden field integration (hfTapMode)

Tap-In inserts, Tap-Out updates (with duplicate prevention)

Alerts that only show date/time for success, not for invalid/already tapped



---

‚úÖ meetingattendance.aspx

<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="meetingattendance.aspx.cs" Inherits="WebApplication1_MAL.meetingattendance1" %>

<!DOCTYPE html>
<html lang="en">
<head runat="server">
    <meta charset="utf-8" />
    <title>Meeting Attendance Tapping</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet" />

    <style>
        .custom-input {
            font-size: 2rem;
            padding: 1rem 1.5rem;
        }
    </style>
</head>
<body>
    <form id="form1" runat="server">
        <div class="container mt-4">
            <h2>
                <asp:Label ID="lblTitle" runat="server" Text="Title"></asp:Label>
            </h2>
            <p>
                <asp:Label ID="lblDateTime" runat="server" Text="Date / Time"></asp:Label>
            </p>

            <!-- Hidden Meeting ID -->
            <asp:HiddenField ID="hfMeetingID" runat="server" />

            <!-- Hidden Tap Mode -->
            <asp:HiddenField ID="hfTapMode" runat="server" Value="In" />

            <div class="row mb-3">
                <div class="col-3">
                    <input type="radio" class="btn-check" name="tapMode" id="radioIn" value="In" autocomplete="off" checked
                           onchange="document.getElementById('<%= hfTapMode.ClientID %>').value=this.value;" />
                    <label class="btn btn-outline-primary w-100 btn-lg" for="radioIn">Tap In</label>
                </div>
                <div class="col-3">
                    <input type="radio" class="btn-check" name="tapMode" id="radioOut" value="Out" autocomplete="off"
                           onchange="document.getElementById('<%= hfTapMode.ClientID %>').value=this.value;" />
                    <label class="btn btn-outline-secondary w-100 btn-lg" for="radioOut">Tap Out</label>
                </div>
            </div>

            <div class="mb-3">
                <asp:TextBox ID="txtCardSerial" runat="server" CssClass="form-control custom-input"
                    placeholder="Place your ID card on the reader"
                    AutoPostBack="true" OnTextChanged="txtCardSerial_TextChanged"></asp:TextBox>
            </div>

            <div id="alertPlaceholder" runat="server"></div>
        </div>
    </form>

    <!-- Bootstrap Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>


---

‚úÖ meetingattendance.aspx.cs

using System;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Web.UI;

namespace WebApplication1_MAL
{
    public partial class meetingattendance1 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                string meetingId = Request.QueryString["meetingId"];
                if (!string.IsNullOrEmpty(meetingId))
                {
                    LoadMeetingDetails(meetingId);
                }
                else
                {
                    lblTitle.Text = "Invalid Meeting";
                    lblDateTime.Text = "";
                }
            }
        }

        private void LoadMeetingDetails(string meetingId)
        {
            string connStr = ConfigurationManager.ConnectionStrings["MeetingDb"].ConnectionString;
            using (SqlConnection conn = new SqlConnection(connStr))
            using (SqlCommand cmd = new SqlCommand("MA_GetMeetingDetails", conn))
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.AddWithValue("@MeetingId", meetingId);

                conn.Open();
                SqlDataReader reader = cmd.ExecuteReader();
                if (reader.Read())
                {
                    lblTitle.Text = reader["Title"].ToString();
                    lblDateTime.Text = $"{reader["Venue"]} / {Convert.ToDateTime(reader["StartDateTime"]):MMMM dd, yyyy hh:mm tt} - {Convert.ToDateTime(reader["EndDateTime"]):hh:mm tt}";
                    hfMeetingID.Value = meetingId;
                }
                else
                {
                    lblTitle.Text = "Meeting not found";
                    lblDateTime.Text = "";
                }
            }
        }

        protected void txtCardSerial_TextChanged(object sender, EventArgs e)
        {
            string cardSerial = txtCardSerial.Text.Trim();
            string meetingId = hfMeetingID.Value;
            string tapMode = hfTapMode.Value; // "In" or "Out"

            if (string.IsNullOrEmpty(cardSerial))
            {
                ShowAlert("Invalid Tap", "Please place your card on the reader.", "", "In", "error");
                return;
            }

            string connStr = ConfigurationManager.ConnectionStrings["MeetingDb"].ConnectionString;
            using (SqlConnection conn = new SqlConnection(connStr))
            {
                conn.Open();

                // 1. Validate Employee
                string empName = "";
                string dept = "";
                string sec = "";

                using (SqlCommand cmd = new SqlCommand("MA_CheckEmployeeByCard", conn))
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                    SqlDataReader reader = cmd.ExecuteReader();
                    if (!reader.Read())
                    {
                        ShowAlert("Card Not Registered", "Unknown Card", "", tapMode, "error");
                        return;
                    }

                    empName = reader["FirstName"].ToString();
                    dept = reader["LastName"].ToString();
                    sec = reader["FirstName"].ToString();
                    reader.Close();
                }

                if (tapMode == "In")
                {
                    // Insert participant (prevent duplicate tap-in)
                    using (SqlCommand insertCmd = new SqlCommand("MA_InsertAttendee", conn))
                    {
                        insertCmd.CommandType = CommandType.StoredProcedure;
                        insertCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                        insertCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                        object result = insertCmd.ExecuteScalar();

                        if (result != null && result.ToString() == "0")
                        {
                            ShowAlert("Already Tapped In", empName, $"{dept} - {sec}", "In", "warning");
                        }
                        else
                        {
                            ShowAlert("You have tapped in successfully!", empName, $"{dept} - {sec}", "In", "success");
                        }
                    }
                }
                else if (tapMode == "Out")
                {
                    // Update TimeOut (prevent multiple tap-outs)
                    using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
                    {
                        updateCmd.CommandType = CommandType.StoredProcedure;
                        updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                        updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                        int rows = updateCmd.ExecuteNonQuery();
                        if (rows == 0)
                        {
                            ShowAlert("Already Tapped Out", empName, $"{dept} - {sec}", "Out", "warning");
                        }
                        else
                        {
                            ShowAlert("You have tapped out successfully!", empName, $"{dept} - {sec}", "Out", "success");
                        }
                    }
                }

                // Clear textbox for next tap
                txtCardSerial.Text = "";
            }
        }

        private void ShowAlert(string title, string name, string deptSec, string mode, string status)
        {
            string alertClass = "alert-secondary";
            string icon = "bi-info-circle-fill";
            string dateTimeHtml = "";

            if (status == "success")
            {
                if (mode == "In")
                {
                    alertClass = "alert-success";
                    icon = "bi-box-arrow-in-right";
                    dateTimeHtml = $"<hr><p class='mb-0'>{DateTime.Now:MMMM dd, yyyy hh:mm tt}</p>";
                }
                else if (mode == "Out")
                {
                    alertClass = "alert-info";
                    icon = "bi-box-arrow-right";
                    dateTimeHtml = $"<hr><p class='mb-0'>{DateTime.Now:MMMM dd, yyyy hh:mm tt}</p>";
                }
            }
            else if (status == "warning")
            {
                alertClass = "alert-warning";
                icon = "bi-exclamation-triangle-fill";
            }
            else if (status == "error")
            {
                alertClass = "alert-danger";
                icon = "bi-x-circle-fill";
            }

            string alertHtml = $@"
                <div class='alert {alertClass} shadow-sm' role='alert'>
                    <h4 class='alert-heading'>
                        <i class='bi {icon}'></i> {title}
                    </h4>
                    <p>{name}</p>
                    <p>{deptSec}</p>
                    {dateTimeHtml}
                </div>";

            alertPlaceholder.InnerHtml = alertHtml;
        }
    }
}


---

‚úÖ With this setup:

Tap-In ‚Üí success alert with DateTime

Tap-Out ‚Üí success alert with DateTime

Invalid tap / already tapped ‚Üí alert without DateTime



---

Do you also want me to make the warning/error alerts smaller (compact Bootstrap style) so that only successful ones look big and emphasized?




-- Update 04:35
Perfect üëç ‚Äî here‚Äôs the stored procedure for Tap-Out (MA_UpdateAttendeeTimeout).
This assumes your MeetingAttendees table has MeetingId, CardSerialNo, TimeIn, and TimeOut.


---

‚úÖ Stored Procedure: MA_UpdateAttendeeTimeout

CREATE PROCEDURE MA_UpdateAttendeeTimeout
    @MeetingId NVARCHAR(50),
    @CardSerialNo NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    -- Update only if the employee already tapped IN and has no TimeOut yet
    UPDATE MeetingAttendees
    SET TimeOut = GETDATE()
    WHERE MeetingId = @MeetingId
      AND CardSerialNo = @CardSerialNo
      AND TimeOut IS NULL;

    -- Returns the number of rows affected
    RETURN @@ROWCOUNT;
END


---

‚úÖ Behavior

If a user already tapped in but has no TimeOut, this will update TimeOut = GETDATE().

If they already tapped out (TimeOut not NULL), nothing happens (returns 0).

If they never tapped in, nothing happens (returns 0).



---

‚úÖ How Your C# Code Uses It

using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
{
    updateCmd.CommandType = CommandType.StoredProcedure;
    updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
    updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

    int rows = updateCmd.ExecuteNonQuery();
    if (rows == 0)
    {
        ShowAlert("Already Tapped Out", empName, $"{dept} - {sec}", "Out", "warning");
    }
    else
    {
        ShowAlert("You have tapped out successfully!", empName, $"{dept} - {sec}", "Out", "success");
    }
}


---

‚ö° Question: do you want me to also give you the Tap-In SP (MA_InsertAttendee) again, so both are in one place for consistency?

