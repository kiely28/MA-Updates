Thanks for sharing your full code üëç
I reviewed both your .aspx markup and code-behind, and overall it looks structured and should work. I‚Äôll highlight some issues, fixes, and suggestions:


---

üîé Markup (ASPX) Issues & Fixes

1. View Attendees Button

<button class="btn btn-info text-white me-2 w-auto">View Attendees</button>

This is plain HTML, so it won‚Äôt trigger your btnViewAttendees_Click event in code-behind.
‚úÖ Replace with:


<asp:Button ID="btnViewAttendees" runat="server" CssClass="btn btn-info text-white me-2 w-auto"
    Text="View Attendees" OnClick="btnViewAttendees_Click" />


2. End Meeting Button

<button class="btn btn-danger w-auto">End Meeting</button>

Same problem: plain <button> won‚Äôt hit server-side events.
‚úÖ Replace with:


<asp:Button ID="btnEndMeeting" runat="server" CssClass="btn btn-danger w-auto"
    Text="End Meeting" OnClick="btnEndMeeting_Click" />




---

üîé Code-behind Issues & Fixes

1. Employee Info Mapping

empName = reader["FirstName"].ToString();
dept = reader["LastName"].ToString();
sec = reader["FirstName"].ToString();

Looks like a copy-paste bug: you assign FirstName twice.
‚úÖ Correct mapping should be (adjust to your table fields):


empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
dept = reader["Department"].ToString();
sec = reader["Section"].ToString();


2. Duplicate Attendee Handling

object result = insertCmd.ExecuteScalar();
if (result != null && result.ToString() == "0")

This works if your stored procedure returns "0" for duplicates.
‚úÖ Consider making it more explicit (e.g., return an output parameter) for readability:


RETURN 0 -- duplicate
RETURN 1 -- success


3. Auto Fade-Out Alert

You correctly used:

ScriptManager.RegisterStartupScript(this, GetType(), "fadeOutAlert", "fadeOutAlert();", true);


‚úÖ Ensure your <form runat="server"> is wrapped inside a ScriptManager:

<asp:ScriptManager ID="ScriptManager1" runat="server" />




---

üîé Recommended Improvements

SQL Injection Safety ‚Üí You already use stored procedures, ‚úÖ good.

Error Handling ‚Üí Wrap DB code in try-catch to show a friendly error in alert.

Separation of Concerns ‚Üí Consider moving DB logic into a helper class (cleaner code-behind).

UX ‚Üí Disable the txtCardSerial after tap for 1s to prevent double-post.



---

‚úÖ With these changes, your page will:

Correctly redirect when clicking "View Attendees".

Handle "End Meeting" server-side.

Show correct employee details.

Keep the Bootstrap alerts working smoothly.



---

Do you want me to add the End Meeting logic in your code-behind (e.g., update meeting status + redirect), or just keep the button wired up?


-- Update 12:20
Good question üëç If you want the cursor to always focus on the txtCardSerial textbox, there are a couple of clean ways to do it in ASP.NET Web Forms.


---

‚úÖ Option 1: Use Page.SetFocus in Page_Load

In your meetingattendance.aspx.cs:

protected void Page_Load(object sender, EventArgs e)
{
    if (!IsPostBack)
    {
        string meetingId = Request.QueryString["meetingId"];
        if (!string.IsNullOrEmpty(meetingId))
        {
            LoadMeetingDetails(meetingId);
        }
        else
        {
            lblTitle.Text = "Invalid Meeting";
            lblDateTime.Text = "";
        }
    }

    // Always focus on the textbox after page load or postback
    Page.SetFocus(txtCardSerial);
}


---

‚úÖ Option 2: Use JavaScript for Continuous Focus

Sometimes after postbacks or if the user clicks elsewhere, the focus is lost.
You can enforce focus via JS:

In your ASPX page (inside <form> but after textbox):

<script type="text/javascript">
    window.onload = function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    };

    // Re-focus after each partial postback (if using UpdatePanel in future)
    Sys.WebForms.PageRequestManager.getInstance().add_endRequest(function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    });
</script>


---

‚úÖ Option 3: Force Focus After Tapping

At the end of your txtCardSerial_TextChanged handler:

txtCardSerial.Text = "";
ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
    $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);

This way, after every tap, the textbox clears and gets focus again.


---

üëâ Best practice:
Use Option 1 (SetFocus) for initial load + Option 3 (set focus again after postback) so your input is always ready for the next card swipe.


---

Do you want me to integrate this directly into your txtCardSerial_TextChanged method and Page_Load so it‚Äôs copy-paste ready?


