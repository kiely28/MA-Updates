Thanks for sharing your full code üëç
I reviewed both your .aspx markup and code-behind, and overall it looks structured and should work. I‚Äôll highlight some issues, fixes, and suggestions:


---

üîé Markup (ASPX) Issues & Fixes

1. View Attendees Button

<button class="btn btn-info text-white me-2 w-auto">View Attendees</button>

This is plain HTML, so it won‚Äôt trigger your btnViewAttendees_Click event in code-behind.
‚úÖ Replace with:


<asp:Button ID="btnViewAttendees" runat="server" CssClass="btn btn-info text-white me-2 w-auto"
    Text="View Attendees" OnClick="btnViewAttendees_Click" />


2. End Meeting Button

<button class="btn btn-danger w-auto">End Meeting</button>

Same problem: plain <button> won‚Äôt hit server-side events.
‚úÖ Replace with:


<asp:Button ID="btnEndMeeting" runat="server" CssClass="btn btn-danger w-auto"
    Text="End Meeting" OnClick="btnEndMeeting_Click" />




---

üîé Code-behind Issues & Fixes

1. Employee Info Mapping

empName = reader["FirstName"].ToString();
dept = reader["LastName"].ToString();
sec = reader["FirstName"].ToString();

Looks like a copy-paste bug: you assign FirstName twice.
‚úÖ Correct mapping should be (adjust to your table fields):


empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
dept = reader["Department"].ToString();
sec = reader["Section"].ToString();


2. Duplicate Attendee Handling

object result = insertCmd.ExecuteScalar();
if (result != null && result.ToString() == "0")

This works if your stored procedure returns "0" for duplicates.
‚úÖ Consider making it more explicit (e.g., return an output parameter) for readability:


RETURN 0 -- duplicate
RETURN 1 -- success


3. Auto Fade-Out Alert

You correctly used:

ScriptManager.RegisterStartupScript(this, GetType(), "fadeOutAlert", "fadeOutAlert();", true);


‚úÖ Ensure your <form runat="server"> is wrapped inside a ScriptManager:

<asp:ScriptManager ID="ScriptManager1" runat="server" />




---

üîé Recommended Improvements

SQL Injection Safety ‚Üí You already use stored procedures, ‚úÖ good.

Error Handling ‚Üí Wrap DB code in try-catch to show a friendly error in alert.

Separation of Concerns ‚Üí Consider moving DB logic into a helper class (cleaner code-behind).

UX ‚Üí Disable the txtCardSerial after tap for 1s to prevent double-post.



---

‚úÖ With these changes, your page will:

Correctly redirect when clicking "View Attendees".

Handle "End Meeting" server-side.

Show correct employee details.

Keep the Bootstrap alerts working smoothly.



---

Do you want me to add the End Meeting logic in your code-behind (e.g., update meeting status + redirect), or just keep the button wired up?


-- Update 12:20
Good question üëç If you want the cursor to always focus on the txtCardSerial textbox, there are a couple of clean ways to do it in ASP.NET Web Forms.


---

‚úÖ Option 1: Use Page.SetFocus in Page_Load

In your meetingattendance.aspx.cs:

protected void Page_Load(object sender, EventArgs e)
{
    if (!IsPostBack)
    {
        string meetingId = Request.QueryString["meetingId"];
        if (!string.IsNullOrEmpty(meetingId))
        {
            LoadMeetingDetails(meetingId);
        }
        else
        {
            lblTitle.Text = "Invalid Meeting";
            lblDateTime.Text = "";
        }
    }

    // Always focus on the textbox after page load or postback
    Page.SetFocus(txtCardSerial);
}


---

‚úÖ Option 2: Use JavaScript for Continuous Focus

Sometimes after postbacks or if the user clicks elsewhere, the focus is lost.
You can enforce focus via JS:

In your ASPX page (inside <form> but after textbox):

<script type="text/javascript">
    window.onload = function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    };

    // Re-focus after each partial postback (if using UpdatePanel in future)
    Sys.WebForms.PageRequestManager.getInstance().add_endRequest(function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    });
</script>


---

‚úÖ Option 3: Force Focus After Tapping

At the end of your txtCardSerial_TextChanged handler:

txtCardSerial.Text = "";
ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
    $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);

This way, after every tap, the textbox clears and gets focus again.


---

üëâ Best practice:
Use Option 1 (SetFocus) for initial load + Option 3 (set focus again after postback) so your input is always ready for the next card swipe.


---

Do you want me to integrate this directly into your txtCardSerial_TextChanged method and Page_Load so it‚Äôs copy-paste ready?



-- Update 12:39
Got it üëç You already have the Tap-In logic (which inserts into MA_InsertAttendee), so for Tap-Out, we‚Äôll just update the record‚Äôs TimeOut instead of inserting again.

Here‚Äôs how we can do it step by step:


---

1. Add Tap Mode Selection (Radio Button)

You already have In/Out radio buttons in your markup.
They just need to be tied to server code.

Change your radio buttons like this:

<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioIn" runat="server" GroupName="TapMode" Checked="true"
        CssClass="btn-check" />
    <label class="btn btn-outline-primary w-100 btn-lg" for="<%= radioIn.ClientID %>">In</label>
</div>
<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioOut" runat="server" GroupName="TapMode"
        CssClass="btn-check" />
    <label class="btn btn-outline-secondary w-100 btn-lg" for="<%= radioOut.ClientID %>">Out</label>
</div>


---

2. Update txtCardSerial_TextChanged

We‚Äôll detect if the user tapped In or Out, then run the correct stored procedure.

protected void txtCardSerial_TextChanged(object sender, EventArgs e)
{
    string cardSerial = txtCardSerial.Text.Trim();
    string meetingId = hfMeetingID.Value;

    if (string.IsNullOrEmpty(cardSerial))
    {
        ShowAlert("Invalid Tap", "Please place your card on the reader.", "", "alert-warning");
        return;
    }

    string connStr = ConfigurationManager.ConnectionStrings["MeetingDb"].ConnectionString;

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        conn.Open();

        // 1. Validate Employee
        string empName = "";
        string dept = "";
        string sec = "";

        using (SqlCommand cmd = new SqlCommand("MA_CheckEmployeeByCard", conn))
        {
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

            SqlDataReader reader = cmd.ExecuteReader();
            if (!reader.Read())
            {
                ShowAlert("Card Not Registered", "Unknown Card", "", "alert-danger");
                return;
            }

            empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
            dept = reader["Department"].ToString();
            sec = reader["Section"].ToString();
            reader.Close();
        }

        // 2. Check tap mode (In/Out)
        if (radioIn.Checked)
        {
            // Insert (Tap-In)
            using (SqlCommand insertCmd = new SqlCommand("MA_InsertAttendee", conn))
            {
                insertCmd.CommandType = CommandType.StoredProcedure;
                insertCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                insertCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                object result = insertCmd.ExecuteScalar();

                if (result != null && result.ToString() == "0")
                {
                    ShowAlert("Already Tapped In", empName, $"{dept} - {sec}", "alert-warning");
                }
                else
                {
                    ShowAlert("You have tapped in successfully!", empName, $"{dept} - {sec}", "alert-success");
                }
            }
        }
        else if (radioOut.Checked)
        {
            // Update (Tap-Out)
            using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
            {
                updateCmd.CommandType = CommandType.StoredProcedure;
                updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                int rows = updateCmd.ExecuteNonQuery();

                if (rows > 0)
                {
                    ShowAlert("You have tapped out successfully!", empName, $"{dept} - {sec}", "alert-info");
                }
                else
                {
                    ShowAlert("No active tap-in found", empName, $"{dept} - {sec}", "alert-warning");
                }
            }
        }

        // Clear for next tap
        txtCardSerial.Text = "";
        ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
            $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);
    }
}


---

3. New Stored Procedure for Tap-Out

Add this to your SQL database:

CREATE PROCEDURE MA_UpdateAttendeeTimeout
    @MeetingId NVARCHAR(50),
    @CardSerialNo NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE MeetingAttendees
    SET TimeOut = GETDATE()
    WHERE MeetingId = @MeetingId
      AND CardSerialNo = @CardSerialNo
      AND TimeOut IS NULL; -- only update if still active
END


---

‚úÖ Now your workflow is:

Tap-In ‚Üí Inserts new record (TimeIn).

Tap-Out ‚Üí Updates TimeOut of the existing record (no duplicate inserts).



---

Do you want me to also prevent multiple Tap-Outs (so they can‚Äôt tap out twice in the same meeting), or should it just silently update TimeOut every time?


