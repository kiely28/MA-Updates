Thanks for sharing your full code üëç
I reviewed both your .aspx markup and code-behind, and overall it looks structured and should work. I‚Äôll highlight some issues, fixes, and suggestions:


---

üîé Markup (ASPX) Issues & Fixes

1. View Attendees Button

<button class="btn btn-info text-white me-2 w-auto">View Attendees</button>

This is plain HTML, so it won‚Äôt trigger your btnViewAttendees_Click event in code-behind.
‚úÖ Replace with:


<asp:Button ID="btnViewAttendees" runat="server" CssClass="btn btn-info text-white me-2 w-auto"
    Text="View Attendees" OnClick="btnViewAttendees_Click" />


2. End Meeting Button

<button class="btn btn-danger w-auto">End Meeting</button>

Same problem: plain <button> won‚Äôt hit server-side events.
‚úÖ Replace with:


<asp:Button ID="btnEndMeeting" runat="server" CssClass="btn btn-danger w-auto"
    Text="End Meeting" OnClick="btnEndMeeting_Click" />




---

üîé Code-behind Issues & Fixes

1. Employee Info Mapping

empName = reader["FirstName"].ToString();
dept = reader["LastName"].ToString();
sec = reader["FirstName"].ToString();

Looks like a copy-paste bug: you assign FirstName twice.
‚úÖ Correct mapping should be (adjust to your table fields):


empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
dept = reader["Department"].ToString();
sec = reader["Section"].ToString();


2. Duplicate Attendee Handling

object result = insertCmd.ExecuteScalar();
if (result != null && result.ToString() == "0")

This works if your stored procedure returns "0" for duplicates.
‚úÖ Consider making it more explicit (e.g., return an output parameter) for readability:


RETURN 0 -- duplicate
RETURN 1 -- success


3. Auto Fade-Out Alert

You correctly used:

ScriptManager.RegisterStartupScript(this, GetType(), "fadeOutAlert", "fadeOutAlert();", true);


‚úÖ Ensure your <form runat="server"> is wrapped inside a ScriptManager:

<asp:ScriptManager ID="ScriptManager1" runat="server" />




---

üîé Recommended Improvements

SQL Injection Safety ‚Üí You already use stored procedures, ‚úÖ good.

Error Handling ‚Üí Wrap DB code in try-catch to show a friendly error in alert.

Separation of Concerns ‚Üí Consider moving DB logic into a helper class (cleaner code-behind).

UX ‚Üí Disable the txtCardSerial after tap for 1s to prevent double-post.



---

‚úÖ With these changes, your page will:

Correctly redirect when clicking "View Attendees".

Handle "End Meeting" server-side.

Show correct employee details.

Keep the Bootstrap alerts working smoothly.



---

Do you want me to add the End Meeting logic in your code-behind (e.g., update meeting status + redirect), or just keep the button wired up?


-- Update 12:20
Good question üëç If you want the cursor to always focus on the txtCardSerial textbox, there are a couple of clean ways to do it in ASP.NET Web Forms.


---

‚úÖ Option 1: Use Page.SetFocus in Page_Load

In your meetingattendance.aspx.cs:

protected void Page_Load(object sender, EventArgs e)
{
    if (!IsPostBack)
    {
        string meetingId = Request.QueryString["meetingId"];
        if (!string.IsNullOrEmpty(meetingId))
        {
            LoadMeetingDetails(meetingId);
        }
        else
        {
            lblTitle.Text = "Invalid Meeting";
            lblDateTime.Text = "";
        }
    }

    // Always focus on the textbox after page load or postback
    Page.SetFocus(txtCardSerial);
}


---

‚úÖ Option 2: Use JavaScript for Continuous Focus

Sometimes after postbacks or if the user clicks elsewhere, the focus is lost.
You can enforce focus via JS:

In your ASPX page (inside <form> but after textbox):

<script type="text/javascript">
    window.onload = function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    };

    // Re-focus after each partial postback (if using UpdatePanel in future)
    Sys.WebForms.PageRequestManager.getInstance().add_endRequest(function () {
        var cardBox = document.getElementById('<%= txtCardSerial.ClientID %>');
        if (cardBox) {
            cardBox.focus();
        }
    });
</script>


---

‚úÖ Option 3: Force Focus After Tapping

At the end of your txtCardSerial_TextChanged handler:

txtCardSerial.Text = "";
ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
    $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);

This way, after every tap, the textbox clears and gets focus again.


---

üëâ Best practice:
Use Option 1 (SetFocus) for initial load + Option 3 (set focus again after postback) so your input is always ready for the next card swipe.


---

Do you want me to integrate this directly into your txtCardSerial_TextChanged method and Page_Load so it‚Äôs copy-paste ready?



-- Update 12:39
Got it üëç You already have the Tap-In logic (which inserts into MA_InsertAttendee), so for Tap-Out, we‚Äôll just update the record‚Äôs TimeOut instead of inserting again.

Here‚Äôs how we can do it step by step:


---

1. Add Tap Mode Selection (Radio Button)

You already have In/Out radio buttons in your markup.
They just need to be tied to server code.

Change your radio buttons like this:

<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioIn" runat="server" GroupName="TapMode" Checked="true"
        CssClass="btn-check" />
    <label class="btn btn-outline-primary w-100 btn-lg" for="<%= radioIn.ClientID %>">In</label>
</div>
<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioOut" runat="server" GroupName="TapMode"
        CssClass="btn-check" />
    <label class="btn btn-outline-secondary w-100 btn-lg" for="<%= radioOut.ClientID %>">Out</label>
</div>


---

2. Update txtCardSerial_TextChanged

We‚Äôll detect if the user tapped In or Out, then run the correct stored procedure.

protected void txtCardSerial_TextChanged(object sender, EventArgs e)
{
    string cardSerial = txtCardSerial.Text.Trim();
    string meetingId = hfMeetingID.Value;

    if (string.IsNullOrEmpty(cardSerial))
    {
        ShowAlert("Invalid Tap", "Please place your card on the reader.", "", "alert-warning");
        return;
    }

    string connStr = ConfigurationManager.ConnectionStrings["MeetingDb"].ConnectionString;

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        conn.Open();

        // 1. Validate Employee
        string empName = "";
        string dept = "";
        string sec = "";

        using (SqlCommand cmd = new SqlCommand("MA_CheckEmployeeByCard", conn))
        {
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

            SqlDataReader reader = cmd.ExecuteReader();
            if (!reader.Read())
            {
                ShowAlert("Card Not Registered", "Unknown Card", "", "alert-danger");
                return;
            }

            empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
            dept = reader["Department"].ToString();
            sec = reader["Section"].ToString();
            reader.Close();
        }

        // 2. Check tap mode (In/Out)
        if (radioIn.Checked)
        {
            // Insert (Tap-In)
            using (SqlCommand insertCmd = new SqlCommand("MA_InsertAttendee", conn))
            {
                insertCmd.CommandType = CommandType.StoredProcedure;
                insertCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                insertCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                object result = insertCmd.ExecuteScalar();

                if (result != null && result.ToString() == "0")
                {
                    ShowAlert("Already Tapped In", empName, $"{dept} - {sec}", "alert-warning");
                }
                else
                {
                    ShowAlert("You have tapped in successfully!", empName, $"{dept} - {sec}", "alert-success");
                }
            }
        }
        else if (radioOut.Checked)
        {
            // Update (Tap-Out)
            using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
            {
                updateCmd.CommandType = CommandType.StoredProcedure;
                updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                int rows = updateCmd.ExecuteNonQuery();

                if (rows > 0)
                {
                    ShowAlert("You have tapped out successfully!", empName, $"{dept} - {sec}", "alert-info");
                }
                else
                {
                    ShowAlert("No active tap-in found", empName, $"{dept} - {sec}", "alert-warning");
                }
            }
        }

        // Clear for next tap
        txtCardSerial.Text = "";
        ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
            $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);
    }
}


---

3. New Stored Procedure for Tap-Out

Add this to your SQL database:

CREATE PROCEDURE MA_UpdateAttendeeTimeout
    @MeetingId NVARCHAR(50),
    @CardSerialNo NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE MeetingAttendees
    SET TimeOut = GETDATE()
    WHERE MeetingId = @MeetingId
      AND CardSerialNo = @CardSerialNo
      AND TimeOut IS NULL; -- only update if still active
END


---

‚úÖ Now your workflow is:

Tap-In ‚Üí Inserts new record (TimeIn).

Tap-Out ‚Üí Updates TimeOut of the existing record (no duplicate inserts).



---

Do you want me to also prevent multiple Tap-Outs (so they can‚Äôt tap out twice in the same meeting), or should it just silently update TimeOut every time?


-- 12:45
Got it üëç ‚Äî I see why your radio buttons aren‚Äôt behaving:

You used Bootstrap‚Äôs btn-check style with plain <input type="radio">, but then in code-behind you tried to check radioIn.Checked.

That works only if the radio is an ASP.NET RadioButton server control.

Right now, your markup has a mismatch: input is HTML, but your code expects <asp:RadioButton>.



---

‚úÖ Fix: Use ASP.NET RadioButton with Bootstrap Styling

Here‚Äôs how to wire it correctly:

<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioIn" runat="server" GroupName="TapMode" Checked="true"
        CssClass="btn-check" />
    <label class="btn btn-outline-primary w-100 btn-lg" for="radioIn">In</label>
</div>

<div class="col-3 col-lg-3 mb-3">
    <asp:RadioButton ID="radioOut" runat="server" GroupName="TapMode"
        CssClass="btn-check" />
    <label class="btn btn-outline-secondary w-100 btn-lg" for="radioOut">Out</label>
</div>


---

üîé Why this works

<asp:RadioButton> renders to <input type="radio"> with an auto-generated ID.

The for="radioIn" on the <label> won‚Äôt match unless you explicitly set the client-side id.

ASP.NET allows this by adding ClientIDMode="Static".


So update it like this:

<asp:RadioButton ID="radioIn" runat="server" GroupName="TapMode" Checked="true"
    CssClass="btn-check" ClientIDMode="Static" />
<label class="btn btn-outline-primary w-100 btn-lg" for="radioIn">In</label>

<asp:RadioButton ID="radioOut" runat="server" GroupName="TapMode"
    CssClass="btn-check" ClientIDMode="Static" />
<label class="btn btn-outline-secondary w-100 btn-lg" for="radioOut">Out</label>

Now:

Bootstrap styling works (btn-check).

Labels toggle correctly.

In C#, you can reliably check:

if (radioIn.Checked) { ... } 
else if (radioOut.Checked) { ... }



---

‚ö° Question for you: Do you want the default mode always set to Tap-In every time the page reloads, or should it remember the last selection (even after postback)?


-- 01:09
Alright üëç let‚Äôs fully integrate the Bootstrap radio toggle + hidden field into your code.


---

‚úÖ Markup (meetingattendance.aspx)

Replace your current radio buttons section with this:

<div class="row">
    <div class="col-3 col-lg-3 mb-3">
        <input type="radio" class="btn-check" name="tapMode" id="radioIn" value="In" autocomplete="off" checked>
        <label class="btn btn-outline-primary w-100 btn-lg" for="radioIn">In</label>
    </div>
    <div class="col-3 col-lg-3 mb-3">
        <input type="radio" class="btn-check" name="tapMode" id="radioOut" value="Out" autocomplete="off">
        <label class="btn btn-outline-secondary w-100 btn-lg" for="radioOut">Out</label>
    </div>
    <div class="col-6 d-flex justify-content-end">
        <div>
            <asp:Button ID="btnViewAttendees" runat="server" CssClass="btn btn-info text-white me-2 w-auto"
                Text="View Attendees" OnClick="btnViewAttendees_Click" />
            <asp:Button ID="btnEndMeeting" runat="server" CssClass="btn btn-danger w-auto"
                Text="End Meeting" OnClick="btnEndMeeting_Click" />
        </div>
    </div>
</div>

<!-- Hidden field to hold selected mode -->
<asp:HiddenField ID="hfTapMode" runat="server" />

And below it (inside the same page, after the form), add:

<script type="text/javascript">
    document.querySelectorAll('input[name="tapMode"]').forEach(function (radio) {
        radio.addEventListener('change', function () {
            document.getElementById('<%= hfTapMode.ClientID %>').value = this.value;
        });
    });

    // Initialize default (In) on page load
    document.addEventListener("DOMContentLoaded", function () {
        document.getElementById('<%= hfTapMode.ClientID %>').value = "In";
    });
</script>


---

‚úÖ Code-behind (meetingattendance.aspx.cs)

Now update your txtCardSerial_TextChanged method like this:

protected void txtCardSerial_TextChanged(object sender, EventArgs e)
{
    string cardSerial = txtCardSerial.Text.Trim();
    string meetingId = hfMeetingID.Value;
    string tapMode = hfTapMode.Value; // "In" or "Out"

    if (string.IsNullOrEmpty(cardSerial))
    {
        ShowAlert("Invalid Tap", "Please place your card on the reader.", "", "alert-warning");
        return;
    }

    string connStr = ConfigurationManager.ConnectionStrings["MeetingDb"].ConnectionString;

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        conn.Open();

        // 1. Validate Employee
        string empName = "";
        string dept = "";
        string sec = "";

        using (SqlCommand cmd = new SqlCommand("MA_CheckEmployeeByCard", conn))
        {
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

            SqlDataReader reader = cmd.ExecuteReader();
            if (!reader.Read())
            {
                ShowAlert("Card Not Registered", "Unknown Card", "", "alert-danger");
                return;
            }

            empName = reader["FirstName"].ToString() + " " + reader["LastName"].ToString();
            dept = reader["Department"].ToString();
            sec = reader["Section"].ToString();
            reader.Close();
        }

        // 2. Tap-In or Tap-Out
        if (tapMode == "In")
        {
            using (SqlCommand insertCmd = new SqlCommand("MA_InsertAttendee", conn))
            {
                insertCmd.CommandType = CommandType.StoredProcedure;
                insertCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                insertCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                object result = insertCmd.ExecuteScalar();

                if (result != null && result.ToString() == "0")
                {
                    ShowAlert("Already Tapped In", empName, $"{dept} - {sec}", "alert-warning");
                }
                else
                {
                    ShowAlert("You have tapped in successfully!", empName, $"{dept} - {sec}", "alert-success");
                }
            }
        }
        else if (tapMode == "Out")
        {
            using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
            {
                updateCmd.CommandType = CommandType.StoredProcedure;
                updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
                updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

                object result = updateCmd.ExecuteScalar();
                int rows = (result != null) ? Convert.ToInt32(result) : 0;

                if (rows > 0)
                {
                    ShowAlert("You have tapped out successfully!", empName, $"{dept} - {sec}", "alert-info");
                }
                else
                {
                    ShowAlert("Already tapped out or no tap-in found", empName, $"{dept} - {sec}", "alert-warning");
                }
            }
        }

        // 3. Reset for next tap
        txtCardSerial.Text = "";
        ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
            $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);
    }
}


---

‚úÖ Flow Now

1. User selects In or Out (Bootstrap toggle).


2. JavaScript updates the hidden field hfTapMode.


3. When ID is tapped ‚Üí server reads hfTapMode.Value.


4. Runs either Insert (Tap-In) or Update (Tap-Out, one time only).


5. Shows the correct Bootstrap alert.




---

Would you like me to also update your ShowAlert so that it uses different alert colors/icons automatically depending on tap mode (In/Out) instead of passing them manually?


