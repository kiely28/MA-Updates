Got it üëç ‚Äî the main issue is that your radio buttons (In / Out) don‚Äôt preserve their checked state after postback because they‚Äôre plain HTML inputs (not asp:RadioButtonList).

Since you already have a hidden field (hfTapMode) that holds the selected mode, you just need to sync it back to the radio buttons on page load.

Here‚Äôs the fix:


---

‚úÖ JavaScript Fix

Replace your current radio button script with this:

<script type="text/javascript">
    // When user changes radio button, update hidden field
    document.querySelectorAll('input[name="tapMode"]').forEach(function (radio) {
        radio.addEventListener('change', function () {
            document.getElementById('<%= hfTapMode.ClientID %>').value = this.value;
        });
    });

    // On page load, restore the radio button from hidden field
    document.addEventListener("DOMContentLoaded", function () {
        var savedMode = document.getElementById('<%= hfTapMode.ClientID %>').value;

        if (!savedMode) {
            savedMode = "In"; // default
            document.getElementById('<%= hfTapMode.ClientID %>').value = savedMode;
        }

        var radioToCheck = document.getElementById("radio" + savedMode);
        if (radioToCheck) {
            radioToCheck.checked = true;
        }
    });
</script>


---

‚úÖ What this does

1. When you click In/Out, the value is saved to the hidden field hfTapMode.


2. After a postback (e.g., when tapping a card), the hidden field still has the last selected value.


3. On page reload, the script checks that value and re-applies it to the correct radio button.




---

üëâ Do you want me to integrate this directly into your full .aspx code so you can copy-paste, or just keep it as a drop-in replacement for your existing script?


---

Ah, I see what‚Äôs happening üëÄ

Right now, both In and Out are using the Bootstrap btn-check + label.btn pattern. Bootstrap automatically adds the "highlight" (active button style) to the label of whichever radio is checked.

But in your restore script, you only set .checked = true without unchecking the other one ‚Äî so both buttons can look highlighted for a moment.


---

‚úÖ Fixed Script (forces only one active button)

<script type="text/javascript">
    // When user changes radio button, update hidden field
    document.querySelectorAll('input[name="tapMode"]').forEach(function (radio) {
        radio.addEventListener('change', function () {
            document.getElementById('<%= hfTapMode.ClientID %>').value = this.value;
        });
    });

    // On page load, restore the radio button from hidden field
    document.addEventListener("DOMContentLoaded", function () {
        var savedMode = document.getElementById('<%= hfTapMode.ClientID %>').value;

        if (!savedMode) {
            savedMode = "In"; // default
            document.getElementById('<%= hfTapMode.ClientID %>').value = savedMode;
        }

        // Uncheck all radios first
        document.querySelectorAll('input[name="tapMode"]').forEach(function (r) {
            r.checked = false;
        });

        // Check only the saved one
        var radioToCheck = document.getElementById("radio" + savedMode);
        if (radioToCheck) {
            radioToCheck.checked = true;
        }
    });
</script>


---

üîß What Changed

1. Before setting the correct one, we clear (checked = false) all radios in the tapMode group.


2. Then we apply the saved one ‚Üí Bootstrap highlights only that label.




---

Do you want me to insert this directly into your full .aspx file and show you exactly where to replace your old script?


---
Got it üëç ‚Äî thanks for the detail.

From what you describe:

When you tap out, your SP (MA_UpdateAttendeeTimeout) updates the Timeout in the database correctly ‚úÖ.

But your app still shows the alert "Already tapped out or no tap-in found" ‚ùå.


That means the stored procedure return value and your C# logic don‚Äôt match.


---

üîé Current Code (Tap Out section)

using (SqlCommand updateCmd = new SqlCommand("MA_UpdateAttendeeTimeout", conn))
{
    updateCmd.CommandType = CommandType.StoredProcedure;
    updateCmd.Parameters.AddWithValue("@MeetingId", meetingId);
    updateCmd.Parameters.AddWithValue("@CardSerialNo", cardSerial);

    object result = updateCmd.ExecuteScalar();
    int rows = (result != null) ? Convert.ToInt32(result) : 0;

    if (rows > 0)
    {
        ShowAlert("You have tapped out successfully!", empName, dept, "alert-info");
    }
    else
    {
        ShowAlert("Already tapped out or no tap-in found", empName, dept, "alert-warning");
    }
}


---

‚ö†Ô∏è Problem

ExecuteScalar() expects the SP to return a single value (like 1 if updated, 0 if not).

If your SP just does an UPDATE ... without a RETURN or SELECT, ExecuteScalar() will return null.

That explains why your alert logic thinks no rows were affected, even though the DB was updated.



---

‚úÖ Fix Option 1: Change to ExecuteNonQuery

If your SP only updates rows and doesn‚Äôt return anything, you should use ExecuteNonQuery():

int rows = updateCmd.ExecuteNonQuery();

if (rows > 0)
{
    ShowAlert("You have tapped out successfully!", empName, dept, "alert-info");
}
else
{
    ShowAlert("Already tapped out or no tap-in found", empName, dept, "alert-warning");
}


---

‚úÖ Fix Option 2: Make SP return a value

If you want to keep ExecuteScalar(), make sure your SP ends with something like:

SELECT @@ROWCOUNT;

or

RETURN @@ROWCOUNT;

That way your C# result will match the number of affected rows.


---

üëâ Question for you:
Do you want me to adjust only your C# code to use ExecuteNonQuery(), or do you also want me to rewrite the stored procedure (MA_UpdateAttendeeTimeout) so it always returns a value to match ExecuteScalar()?


