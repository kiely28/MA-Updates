Good day!

The macro file has already been updated and attached for your reference. The latest version includes the following:

- The PO Week format has been retained
- The affected columns have been moved from AX to AZ
- For the PO Week conversion, Column BA (which is hidden upon opening the Excel file) is used to check and validate the OB date in Column AK

Please let me know if this is working as expected or if there are any further adjustments needed.

Thank you po.

Best regards,
King



**


Good day!

Thank you for the feedback. Noted on the additional change ‚Äî I will update the macro to move the affected columns from AX to AZ.

I‚Äôll send the updated file once the change is completed. Please let me know if there‚Äôs anything else you‚Äôd like me to adjust.

Thank you po.

Best regards,
Kheanne Maldia


**


Dear Aizawa san,

Good day!

Please see the attached updated macro file with the following changes:

1. Column K Update
   - Column K now automatically converts the PO Week value into a proper date format using the current year.

2. Row Highlight Behavior Update
   - The row highlighting logic has been updated to prevent rows from being highlighted when new rows are added or existing rows are deleted.
   - Highlighting will now apply only when there is an actual data change in the specified columns.

Please let me know if this is working as expected or if there are any further adjustments needed.

Thank you po.

Regards,
King 





**

Here‚Äôs a polished and corrected version of your email. I kept your structure and tone, just fixed minor grammar and wording for clarity üëç

Good day,

Please see the attached updated macro file with the following changes:

1. Column K Update

   - Column K now automatically converts the PO Week value into a proper date format.

2. Row Highlight Behavior Update

   - The row highlighting logic has been improved to prevent rows from being highlighted when new rows are added or existing rows are deleted.
   - Highlighting will now apply only when there is an actual data change in the specified columns.

Please let me know if this is working as expected or if there are any further adjustments needed.

Thank you.

Best regards,
Kheanne MaldiaIf you want, I can also:

Make it more casual

Add a screenshot reference

Adjust it to sound more formal or concise

**

Sure üëç
We‚Äôll limit the green highlight to columns A‚ÄìAK only, while keeping:

üî¥ Red font only in columns 36, 37, 39, 40, 43

‚ôªÔ∏è Reset formatting when all monitored values are cleared

üö´ Ignore row insert / delete

‚ñ∂Ô∏è Auto-run on change



---

‚úÖ FINAL VBA CODE (Row highlight A ‚Üí AK only)

üìå Paste this into the worksheet code

Private Sub Worksheet_Change(ByVal Target As Range)

    Dim c As Range
    Dim r As Long
    Dim hasValue As Boolean
    Dim col As Variant
    Dim watchCols As Variant

    ' Ignore insert/delete rows or columns
    If Target.Rows.Count > 1 Or Target.Columns.Count > 1 Then Exit Sub

    ' Columns to monitor (numbers)
    watchCols = Array(36, 37, 39, 40, 43)

    ' Exit if change is not in monitored columns
    If Intersect(Target, Me.Range("AJ:AJ,AK:AK,AM:AM,AN:AN,AQ:AQ")) Is Nothing Then Exit Sub

    Application.EnableEvents = False

    For Each c In Target

        r = c.Row
        hasValue = False

        ' Check if ANY monitored column has a value
        For Each col In watchCols
            If Trim(Me.Cells(r, col).Value & "") <> "" Then
                hasValue = True
                Exit For
            End If
        Next col

        If hasValue Then
            ' Highlight row from column A to AK only
            Me.Range("A" & r & ":AK" & r).Interior.Color = RGB(0, 255, 0)

            ' Set red font only in monitored columns
            If Not IsError(Application.Match(c.Column, watchCols, 0)) Then
                c.Font.Color = RGB(255, 0, 0)
            End If
        Else
            ' Reset background A:AK
            Me.Range("A" & r & ":AK" & r).Interior.Pattern = xlNone

            ' Reset font color in monitored columns
            For Each col In watchCols
                Me.Cells(r, col).Font.ColorIndex = xlAutomatic
            Next col
        End If

    Next c

    Application.EnableEvents = True

End Sub


---

üéØ RESULT SUMMARY

Action	Result

Edit AJ, AK, AM, AN, AQ	A‚ÄìAK row turns üü¢
Those columns only	Font turns üî¥
Clear all monitored cells	Formatting resets
Insert / delete row	‚ùå Ignored
Edit other columns	‚ùå No effect



---

üîß Want enhancements?

Different colors per column

Partial reset (cell only)

Log changed rows to another sheet

Make A‚ÄìAK dynamic (based on last used column)


Just tell me üëç

** 

Got it üëç
Below is the enhanced version that will:

‚úÖ Behavior

Row turns GREEN when any of the monitored columns is edited

Font turns RED only in the monitored columns

If a monitored cell is CLEARED:

That cell‚Äôs font color is reset

If ALL monitored columns in that row are empty, the row formatting is fully reset


‚ùå Insert/Delete row is ignored

‚ùå No type mismatch errors



---

‚úÖ FINAL VBA CODE (WITH RESET LOGIC)

üìå Paste this into the worksheet code

Private Sub Worksheet_Change(ByVal Target As Range)

    Dim chkCols As Range
    Dim c As Range
    Dim r As Long
    Dim hasValue As Boolean
    Dim col As Variant

    ' Ignore insert/delete rows or columns
    If Target.Rows.Count > 1 Or Target.Columns.Count > 1 Then Exit Sub

    ' Columns to monitor
    Set chkCols = Union(Me.Columns(36), Me.Columns(37), _
                        Me.Columns(39), Me.Columns(40), _
                        Me.Columns(43))

    ' Exit if change is outside monitored columns
    If Intersect(Target, chkCols) Is Nothing Then Exit Sub

    Application.EnableEvents = False

    For Each c In Intersect(Target, chkCols)

        r = c.Row
        hasValue = False

        ' Check if ANY monitored column in the row has a value
        For Each col In Array(36, 37, 39, 40, 43)
            If Trim(Me.Cells(r, col).Value & "") <> "" Then
                hasValue = True
                Exit For
            End If
        Next col

        If hasValue Then
            ' Apply formatting
            Me.Rows(r).Interior.Color = RGB(0, 255, 0)
            c.Font.Color = RGB(255, 0, 0)
        Else
            ' Reset formatting if all monitored cells are empty
            Me.Rows(r).Interior.Pattern = xlNone

            For Each col In Array(36, 37, 39, 40, 43)
                Me.Cells(r, col).Font.ColorIndex = xlAutomatic
            Next col
        End If

    Next c

    Application.EnableEvents = True

End Sub


---

üß† Logic Explained (Simple)

Clears only when all monitored columns are empty

Prevents accidental loss of highlight if one column still has data

Safe for manual typing, paste, delete



---

üîß Optional (can add next):

Reset formatting only for the cleared cell

Keep history of changed rows

Apply borders instead of fill color

Make colors configurable via cells


Just tell me üëç


***

Perfect ‚Äî we‚Äôll keep the row background GREEN, but make the font RED only for columns 36, 37, 39, 40, and 43 üëç
This version also ignores row insert/delete.


---

‚úÖ FINAL WORKING VBA CODE

üìå Paste this inside the worksheet code (Sheet1, etc.)

Private Sub Worksheet_Change(ByVal Target As Range)

    Dim chkCols As Range
    Dim c As Range

    ' Ignore row/column insert or delete
    If Target.Rows.Count > 1 Or Target.Columns.Count > 1 Then Exit Sub

    ' Columns to monitor
    Set chkCols = Union(Me.Columns(36), Me.Columns(37), _
                        Me.Columns(39), Me.Columns(40), _
                        Me.Columns(43))

    ' Exit if change is outside monitored columns
    If Intersect(Target, chkCols) Is Nothing Then Exit Sub

    Application.EnableEvents = False

    For Each c In Intersect(Target, chkCols)

        ' Set entire row background to GREEN
        Me.Rows(c.Row).Interior.Color = RGB(0, 255, 0)

        ' Set font color RED only for the changed column
        c.Font.Color = RGB(255, 0, 0)

    Next c

    Application.EnableEvents = True

End Sub


---

üéØ RESULT

Action	Effect

Edit col 36 / 37 / 39 / 40 / 43	Row turns GREEN
Only those columns	Font turns RED
Insert/Delete row	‚ùå No highlight
Edit other columns	‚ùå No effect
Type mismatch errors	‚ùå None



---

üîß Optional upgrades (just tell me):

Reset formatting if value is cleared

Highlight only once (no re-trigger)

Store ‚Äúchanged rows‚Äù even after reopening

Convert this logic to Conditional Formatting


You‚Äôre very close to a production-ready Excel tracker üëå



***


Good observation üëç
That happens because row insert / row delete also triggers Worksheet_Change, and Excel treats it as a ‚Äúchange‚Äù in those columns.

To fix this, we need to ignore structural changes (insert/delete) and only react to actual cell edits.


---

‚úÖ FIXED & SAFE VERSION (ignores insert/delete rows)

‚úî What this version does

‚úÖ Highlights only when a cell value is edited

‚ùå Does NOT highlight when:

inserting a row

deleting a row

pasting entire rows


‚úÖ No type mismatch errors



---

üîß Updated VBA Code (replace your existing code)

üìå Still goes inside the worksheet code

Private Sub Worksheet_Change(ByVal Target As Range)

    Dim chkCols As Range
    Dim c As Range

    ' Ignore whole-row or whole-column changes (insert/delete)
    If Target.Rows.Count > 1 Or Target.Columns.Count > 1 Then Exit Sub

    ' Columns to monitor
    Set chkCols = Union(Me.Columns(36), Me.Columns(37), _
                        Me.Columns(39), Me.Columns(40), _
                        Me.Columns(43))

    ' Exit if change is outside monitored columns
    If Intersect(Target, chkCols) Is Nothing Then Exit Sub

    Application.EnableEvents = False

    For Each c In Intersect(Target, chkCols)
        With Me.Rows(c.Row)
            .Interior.Color = RGB(0, 255, 0) ' Green row
            .Font.Color = RGB(255, 0, 0)     ' Red font
        End With
    Next c

    Application.EnableEvents = True

End Sub


---

üß† Why this works

If Target.Rows.Count > 1 Or Target.Columns.Count > 1 Then Exit Sub

Row insert/delete affects multiple cells

Actual typing affects only one cell

This line filters them out completely



---

üîÅ OPTIONAL (Recommended)

If you want:

Reset row color when values are cleared

Detect real value change (before vs after)

Only color specific columns instead of full row

Keep highlight even after workbook reopens


Just tell me which one you want next üëç


**

Below is a safe, copy-paste ready VBA solution that:

Automatically runs when data changes

Highlights the entire row GREEN

Changes the font to RED

Triggers only when columns 36, 37, 39, 40, or 43 change

Avoids ‚ÄúType mismatch‚Äù errors when editing other columns



---

‚úÖ How it works

Uses Worksheet_Change (event-based, auto run)

Checks only the specified columns

Formats only the affected row

Disables events temporarily to prevent loops



---

üìå Columns involved

Column Number	Column Letter

36	AJ
37	AK
39	AM
40	AN
43	AQ



---

üß© VBA CODE (Put this in the worksheet, NOT a module)

Steps:

1. Press ALT + F11


2. Double-click the sheet name (e.g. Sheet1)


3. Paste this code üëá



Private Sub Worksheet_Change(ByVal Target As Range)

    Dim chkCols As Range
    Dim c As Range

    ' Columns to monitor
    Set chkCols = Union(Me.Columns(36), Me.Columns(37), _
                        Me.Columns(39), Me.Columns(40), _
                        Me.Columns(43))

    ' Exit if change is outside monitored columns
    If Intersect(Target, chkCols) Is Nothing Then Exit Sub

    Application.EnableEvents = False

    For Each c In Intersect(Target, chkCols)
        With Me.Rows(c.Row)
            .Interior.Color = RGB(0, 255, 0) ' Green background
            .Font.Color = RGB(255, 0, 0)     ' Red font
        End With
    Next c

    Application.EnableEvents = True

End Sub


---

‚ö†Ô∏è Why this avoids Type Mismatch errors

No comparison of old vs new values (which causes errors)

Only reacts to where the change happened

Uses Intersect safely



---

üü¢ Optional Enhancements (tell me if you want):

Compare old vs new value before highlighting

Highlight only specific columns, not entire row

Reset formatting if value is reverted

Convert this to Conditional Formatting instead


If you want a version that detects actual value change (before vs after), just say üëç

** other prompt

Got it üëç
To auto-run when data changes, you must use a Worksheet_Change event (this goes into the sheet code, not a normal module).

Below is a safe, complete implementation that:

Triggers automatically when data changes

Monitors columns 36, 37, 39, 40, 43 only

Compares the row with the previous row

Colors the entire row ‚Üí Green background + Red font

Prevents infinite loops



---

‚úÖ STEP 1: Put this code in the SHEET (not Module)

1. Press ALT + F11


2. In VBA Editor ‚Üí double-click your worksheet
(e.g. Sheet1 (PO_Data))


3. Paste the code below




---

üìå Auto-Run Highlight on Change

Private Sub Worksheet_Change(ByVal Target As Range)

    Dim colsToCheck As Variant
    Dim c As Variant
    Dim r As Long
    Dim isChanged As Boolean

    ' Columns to monitor
    colsToCheck = Array(36, 37, 39, 40, 43)

    ' Exit if more than one row is changed (paste protection)
    If Target.Rows.Count > 1 Then Exit Sub

    ' Exit if change is not in monitored columns
    If Intersect(Target, Me.Columns(colsToCheck)) Is Nothing Then Exit Sub

    Application.EnableEvents = False

    r = Target.Row

    ' Skip header or first data row
    If r <= 2 Then GoTo SafeExit

    isChanged = False

    ' Compare with previous row
    For Each c In colsToCheck
        If Me.Cells(r, c).Value <> Me.Cells(r - 1, c).Value Then
            isChanged = True
            Exit For
        End If
    Next c

    ' Apply formatting
    If isChanged Then
        Me.Rows(r).Interior.Color = RGB(0, 255, 0) ' Green
        Me.Rows(r).Font.Color = RGB(255, 0, 0)     ' Red
    Else
        ' Optional: reset formatting if no change
        Me.Rows(r).Interior.ColorIndex = xlNone
        Me.Rows(r).Font.ColorIndex = xlAutomatic
    End If

SafeExit:
    Application.EnableEvents = True

End Sub


---

‚ö†Ô∏è IMPORTANT NOTES

This must be inside the worksheet, not Module1

Works when:

User edits cells

Formula results change


Won‚Äôt loop infinitely because EnableEvents is disabled safely



---

üî• Optional (Tell me which one you want)

1. Highlight only changed cells, not entire row


2. Compare against a reference sheet


3. Keep highlight permanent once changed


4. Handle paste / multiple row changes


5. Use Conditional Formatting instead (no VBA)



Just tell me what you want next üòä



**


Yes üëç Conditional Formatting is actually the BEST solution for this case‚Äîno VBA, auto-updates instantly, and safer.

Below is a step-by-step conditional formatting formula that will:

Compare current row vs previous row

Check columns 36, 37, 39, 40, 43

If ANY column changed

Color the entire row ‚Üí Green fill + Red font

Auto-update when data changes



---

‚úÖ STEP-BY-STEP: Conditional Formatting Rule

1Ô∏è‚É£ Select your data range

Example:

Select from Row 2 downward


A2:AZ1000   (adjust as needed)

> Row 1 is header, so we start at Row 2.




---

2Ô∏è‚É£ Create Conditional Formatting Rule

1. Go to Home ‚Üí Conditional Formatting


2. Click New Rule


3. Select ‚ÄúUse a formula to determine which cells to format‚Äù




---

3Ô∏è‚É£ Paste this Formula

=OR(
AJ2<>AJ1,
AK2<>AK1,
AM2<>AM1,
AN2<>AN1,
AQ2<>AQ1
)

üìå Column reference mapping:

AJ = 36

AK = 37

AM = 39

AN = 40

AQ = 43



---

4Ô∏è‚É£ Set the Format

Fill ‚Üí Green

Font color ‚Üí Red

Click OK ‚Üí OK



---

‚úÖ RESULT

If any monitored column differs from the previous row

The entire row turns green with red text

Updates automatically on edit or formula recalculation

No macro required üíØ



---

üîß OPTIONAL IMPROVEMENTS

Ignore blanks (recommended)

If blanks should not trigger changes:

=OR(
AND(AJ2<>"",AJ1<>"",AJ2<>AJ1),
AND(AK2<>"",AK1<>"",AK2<>AK1),
AND(AM2<>"",AM1<>"",AM2<>AM1),
AND(AN2<>"",AN1<>"",AN2<>AN1),
AND(AQ2<>"",AQ1<>"",AQ2<>AQ1)
)


---

Highlight only specific columns (not entire row)

Apply the rule only to:

AJ2, AK2, AM2, AN2, AQ2


---

Compare against a fixed reference row (instead of previous row)

Tell me and I‚Äôll adjust the formula.


---

If you want, I can:

Convert this to Table format

Add date-based highlighting

Combine with icon sets

Optimize for large datasets


Just tell me üëç


**


Got it üëç
The issue happens because Column K is only being converted when the later date-check logic runs, so it may update only once or inconsistently.

‚úÖ Correct approach

üëâ Convert Column K at the START of each row loop, so it is updated once per row, independent of any later conditions.

Below is the corrected and clean implementation.


---

‚úÖ WHAT CHANGED (IMPORTANT)

Column K conversion is moved to the TOP of the loop

Conversion runs once per row

Wednesday calculation uses the already-converted date

No repeated overwrites

Safe if Column K is already a valid date



---

‚úÖ UPDATED CODE (READY TO COPY)

üîπ Replace your loop section with this structure

For i = 14 To lastRow

    '==============================
    ' CONVERT COLUMN K (ONCE ONLY)
    '==============================
    Dim rawPO As String
    Dim poMonth As Integer
    Dim poDay As Integer
    Dim poYear As Integer

    rawPO = UCase(Trim(ws.Cells(i, "K").Value))

    ' Convert ONLY if not yet a date
    If rawPO <> "" And Not IsDate(ws.Cells(i, "K").Value) Then

        Select Case Left(rawPO, 3)
            Case "JAN": poMonth = 1
            Case "FEB": poMonth = 2
            Case "MAR": poMonth = 3
            Case "APR": poMonth = 4
            Case "MAY": poMonth = 5
            Case "JUN": poMonth = 6
            Case "JUL": poMonth = 7
            Case "AUG": poMonth = 8
            Case "SEP": poMonth = 9
            Case "OCT": poMonth = 10
            Case "NOV": poMonth = 11
            Case "DEC": poMonth = 12
            Case Else: poMonth = 0
        End Select

        poDay = Val(Mid(rawPO, 5, 2))
        poYear = 2026   ' <<< change if needed

        If poMonth > 0 And poDay > 0 Then
            ws.Cells(i, "K").Value = DateSerial(poYear, poMonth, poDay)
            ws.Cells(i, "K").NumberFormat = "m/d/yyyy"
        End If
    End If
    '==============================
    ' END COLUMN K CONVERSION
    '==============================


    ' --- EXISTING LOGIC CONTINUES ---
    If ws.Cells(i, "AI").Value <> "" Then

        Set FindRng = wsSrc.Range("E2:E" & lastRowSrc).Find( _
            What:=ws.Cells(i, "AI").Value, LookIn:=xlValues, LookAt:=xlWhole)

        If Not FindRng Is Nothing Then

            ' (your existing copy logic here‚Ä¶)

            '=============================================
            ' CALCULATE WEDNESDAY OF NEXT WEEK AFTER PO
            '=============================================
            If IsDate(ws.Cells(i, "K").Value) And IsDate(ws.Cells(i, "AK").Value) Then

                poDate = ws.Cells(i, "K").Value
                checkDate = ws.Cells(i, "AK").Value

                dayNum = Weekday(poDate, vbSunday)
                daysToNextWednesday = ((4 - dayNum) + 7) Mod 7 + 7
                targetWednesday = poDate + daysToNextWednesday

                If checkDate >= targetWednesday Then
                    ws.Cells(i, "AX").Value = "O"
                Else
                    ws.Cells(i, "AX").ClearContents
                End If
            End If
            '=============================================

        End If
    End If

Next i


---

‚úÖ RESULT

‚úî Column K is converted once per row
‚úî Conversion is independent of the Wednesday logic
‚úî No duplicate or skipped updates
‚úî Wednesday calculation always uses a real date


---

üîß OPTIONAL (If you want)

I can:

Make the year dynamic (from C12 or fiscal year logic)

Move the conversion into a Function for cleaner code

Support formats like DEC01PO, DEC-01, DEC 1


Just tell me üëç


**


In my Column K this is the sample data: DEC 01PO WK 
how to convert into date like this: 12/1/2026


before Calculate Wednesday of the next week after PO date


CODE:

Sub CompareAndCopyData() ' 11/03/25

    ' Declare all variables used
    Dim ws As Worksheet              ' Target sheet (in this workbook)
    Dim wsSrc As Worksheet           ' Source sheet (from opened file)
    Dim wbSrc As Workbook            ' Source workbook
    Dim FilePath As Variant          ' Selected file path
    Dim lastRow As Long              ' Last row in target sheet
    Dim lastRowSrc As Long           ' Last row in source sheet
    Dim i As Long                    ' Loop counter
    Dim FindRng As Range             ' Found cell range
    Dim SourceValueS As String       ' Value from column S
    Dim SourceValueT As String       ' Value from column T
    Dim CommaPosS As Long            ' Position of comma in column S
    Dim CommaPosT As Long            ' Position of comma in column T
    Dim S_Before As String, S_After As String
    Dim T_Before As String, T_After As String
    Dim poDate As Date, checkDate As Date, targetWednesday As Date
    Dim dayNum As Integer, daysToNextWednesday As Integer

    ' Speed up execution and prevent screen flicker
    Application.ScreenUpdating = False
    'Application.EnableEvents = False

    ' Set target worksheet
    Set ws = ThisWorkbook.Sheets("Sheet1")

    ' To select a source Excel file
    FilePath = Application.GetOpenFilename("Excel Files (*.xls*), *.xls*")
    If FilePath = False Then Exit Sub ' Exit if no file selected

    ' Open the selected workbook and set the source sheet
    Set wbSrc = Workbooks.Open(FilePath)
    Set wsSrc = wbSrc.Sheets(1)

    ' Find the last used rows
    lastRow = ws.Cells(ws.Rows.Count, "AI").End(xlUp).Row
    lastRowSrc = wsSrc.Cells(wsSrc.Rows.Count, "E").End(xlUp).Row

    ' Loop through all rows starting from row 14
    For i = 14 To lastRow
        If ws.Cells(i, "AI").Value <> "" Then ' Only if AI has data

            ' Find matching value in source Column E
            Set FindRng = wsSrc.Range("E2:E" & lastRowSrc).Find( _
                What:=ws.Cells(i, "AI").Value, LookIn:=xlValues, LookAt:=xlWhole)

            If Not FindRng Is Nothing Then ' If a match is found

                Dim firstAddress As String
                Dim matchFound As Boolean
                matchFound = False

                ' Copy column G value to AJ (only if AJ is empty)
                If Trim(ws.Cells(i, "AJ").Value) = "" Then

                    ' If source G has data, copy it directly
                    If Trim(wsSrc.Cells(FindRng.Row, "G").Value) <> "" Then
                        ws.Cells(i, "AJ").Value = wsSrc.Cells(FindRng.Row, "G").Value
                        matchFound = True
                    Else
                        ' If G is empty, find next same E with non-empty G
                        firstAddress = FindRng.Address
                        Do
                            Set FindRng = wsSrc.Range("E2:E" & lastRowSrc).FindNext(FindRng)
                            If FindRng Is Nothing Then Exit Do
                            If FindRng.Address = firstAddress Then Exit Do
                            If Trim(wsSrc.Cells(FindRng.Row, "G").Value) <> "" Then
                                ws.Cells(i, "AJ").Value = wsSrc.Cells(FindRng.Row, "G").Value
                                matchFound = True
                                Exit Do
                            End If
                        Loop
                    End If
                End If

                ' Copy X - AK and AC - AQ
                ws.Cells(i, "AK").Value = wsSrc.Cells(FindRng.Row, "X").Value
                ws.Cells(i, "AQ").Value = wsSrc.Cells(FindRng.Row, "AC").Value

                ' Handle S and T column logic
                SourceValueS = Trim(wsSrc.Cells(FindRng.Row, "S").Value)
                SourceValueT = Trim(wsSrc.Cells(FindRng.Row, "T").Value)

                ' Get comma position to split before/after
                CommaPosS = InStr(1, SourceValueS, ",")
                CommaPosT = InStr(1, SourceValueT, ",")

                If CommaPosS = 0 Then
                    ' If no comma, treat as direct values
                    ws.Cells(i, "AM").Value = SourceValueS & " " & SourceValueT
                    ws.Cells(i, "AN").Value = "DIRECT"
                Else
                    ' Split values before and after comma
                    S_Before = Trim(Left(SourceValueS, CommaPosS - 1))
                    S_After = Trim(Mid(SourceValueS, CommaPosS + 1))

                    If CommaPosT > 0 Then
                        T_Before = Trim(Left(SourceValueT, CommaPosT - 1))
                        T_After = Trim(Mid(SourceValueT, CommaPosT + 1))
                    Else
                        T_Before = SourceValueT
                        T_After = SourceValueT
                    End If

                    ' Write separated values
                    ws.Cells(i, "AM").Value = S_Before & " " & T_Before
                    ws.Cells(i, "AN").Value = S_After & " " & T_After
                End If

                ' Calculate Wednesday of the next week after PO date
                If IsDate(ws.Cells(i, "K").Value) And IsDate(ws.Cells(i, "AK").Value) Then
                    poDate = ws.Cells(i, "K").Value
                    checkDate = ws.Cells(i, "AK").Value

                    dayNum = Weekday(poDate, vbSunday)
                    daysToNextWednesday = ((4 - dayNum) + 7) Mod 7 + 7
                    targetWednesday = poDate + daysToNextWednesday

                    ' Mark "O" if checkDate >= targetWednesday
                    If checkDate >= targetWednesday Then
                        ws.Cells(i, "AX").Value = "O"
                    Else
                        ws.Cells(i, "AX").ClearContents
                    End If
                End If

            End If
        End If
    Next i

    ' Close the source workbook without saving
    wbSrc.Close SaveChanges:=False

    ' Restore Excel settings
    Application.ScreenUpdating = True
    'Application.EnableEvents = True

    ' Notify when done
    'MsgBox "Process completed.", vbInformation

End Sub



***


Below is a safe and copy-paste‚Äìready solution that converts Column K text like
DEC 01PO WK ‚Üí 12/1/2026 (real Date value)
before your existing ‚ÄúCalculate Wednesday of the next week after PO date‚Äù logic runs.

I will not change your logic, only insert a conversion block before it, exactly as requested.


---

‚úÖ What the solution does

Extracts Month (DEC)

Extracts Day (01)

Ignores trailing text (PO WK)

Converts it to a real VBA Date

Forces Year = 2026 (you can change this easily)

Writes the converted date back into Column K



---

‚úÖ ADD THIS CODE BLOCK

üìç Insert this just BEFORE:

' Calculate Wednesday of the next week after PO date
If IsDate(ws.Cells(i, "K").Value) And IsDate(ws.Cells(i, "AK").Value) Then


---

üîπ PO Date Text ‚Üí Date Conversion (Column K)

' --- Convert PO Date text like "DEC 01PO WK" to Date (12/1/2026) ---
Dim rawPO As String
Dim poMonth As Integer
Dim poDay As Integer
Dim poYear As Integer

rawPO = UCase(Trim(ws.Cells(i, "K").Value))

' Only convert if Column K is NOT already a date
If Not IsDate(ws.Cells(i, "K").Value) Then

    ' Extract month (first 3 letters)
    Select Case Left(rawPO, 3)
        Case "JAN": poMonth = 1
        Case "FEB": poMonth = 2
        Case "MAR": poMonth = 3
        Case "APR": poMonth = 4
        Case "MAY": poMonth = 5
        Case "JUN": poMonth = 6
        Case "JUL": poMonth = 7
        Case "AUG": poMonth = 8
        Case "SEP": poMonth = 9
        Case "OCT": poMonth = 10
        Case "NOV": poMonth = 11
        Case "DEC": poMonth = 12
        Case Else: poMonth = 0
    End Select

    ' Extract day (characters 5‚Äì6 ‚Üí "01")
    If poMonth > 0 And Len(rawPO) >= 6 Then
        poDay = Val(Mid(rawPO, 5, 2))
    End If

    ' Set year (CHANGE if needed)
    poYear = 2026

    ' Build date if valid
    If poMonth > 0 And poDay > 0 Then
        ws.Cells(i, "K").Value = DateSerial(poYear, poMonth, poDay)
        ws.Cells(i, "K").NumberFormat = "m/d/yyyy"
    End If

End If
' --- End PO Date Conversion ---


---

‚úÖ RESULT

Original (K)	After Macro

DEC 01PO WK	12/1/2026
JAN 15PO WK	1/15/2026


Column K becomes a real date, so your existing logic:

If IsDate(ws.Cells(i, "K").Value)

‚úÖ WILL NOW WORK CORRECTLY


---

üîß Optional Improvements (tell me if you want these)

Auto-detect year based on fiscal year

Take year from another column (ex: C12)

Handle formats like DEC01 PO WK, DEC-01, etc.

Move conversion into a reusable function


Just tell me üëç

**

please add a change the row to green and the font to red if there is a change in any of columns 36, 37, 39, 40, or 43 in Excel.



